#!/usr/bin/env tsx

/**
 * VEO3 Video Generation Script
 *
 * Generates video from text prompt, optionally using an image as the first frame.
 * This enables the powerful workflow: NanoBanana/SeedDream â†’ VEO3
 *
 * Usage:
 *   # Generate video from prompt only
 *   tsx generate-veo3.ts \
 *     --prompt "Panning wide shot of a calico kitten sleeping in the sunshine"
 *
 *   # Generate video from existing image
 *   tsx generate-veo3.ts \
 *     --prompt "Camera slowly zooms out from the portrait" \
 *     --image ./assets/generated/portrait.png
 *
 *   # Full pipeline: Generate image with NanoBanana, then animate with VEO3
 *   tsx generate-veo3.ts \
 *     --prompt "Wide shot of a modern office space with natural lighting" \
 *     --generate-image
 *
 * Output:
 *   JSON object with operation ID and status printed to stdout
 */

import 'dotenv/config';
import { parseArgs } from 'node:util';
import { readFileSync } from 'node:fs';
import { GoogleGenAI } from '@google/genai';

/**
 * Parse command-line arguments
 */
function parseArguments() {
  const { values } = parseArgs({
    options: {
      prompt: {
        type: 'string',
        short: 'p',
      },
      image: {
        type: 'string',
        short: 'i',
      },
      'generate-image': {
        type: 'boolean',
        default: false,
      },
      model: {
        type: 'string',
        short: 'm',
        default: 'veo-3.1-generate-preview',
      },
      'aspect-ratio': {
        type: 'string',
        short: 'a',
        default: '9:16',
      },
      resolution: {
        type: 'string',
        short: 'r',
        default: '720p',
      },
      duration: {
        type: 'string',
        short: 'd',
        default: '8',
      },
      help: {
        type: 'boolean',
        short: 'h',
        default: false,
      },
    },
  });

  return values;
}

/**
 * Display help message
 */
function showHelp() {
  console.log(`
VEO3 Video Generation Script

Usage:
  tsx generate-veo3.ts [options]

Options:
  -p, --prompt <text>        Video description prompt (required)
  -i, --image <path>         Path to image to use as first frame (optional)
  --generate-image           Generate first frame with Nano Banana, then animate (optional)
  -m, --model <model>        Model to use (default: veo-3.1-generate-preview)
  -a, --aspect-ratio <ratio> Aspect ratio: 16:9 or 9:16 (default: 9:16 for vertical)
  -r, --resolution <res>     Resolution: 720p or 1080p (default: 720p)
  -d, --duration <seconds>   Duration in seconds: 4-8 (default: 8)
  -h, --help                 Show this help message

Workflows:

  1. Text-to-Video (prompt only):
     tsx generate-veo3.ts \\
       --prompt "Wide shot of a modern office, camera panning slowly"

  2. Image-to-Video (animate existing image):
     tsx generate-veo3.ts \\
       --prompt "Camera zooms out slowly" \\
       --image ./assets/portrait.png

  3. Full Pipeline (generate image, then animate):
     tsx generate-veo3.ts \\
       --prompt "Wide shot of a cozy coffee shop with warm lighting" \\
       --generate-image

Environment:
  GOOGLE_GENAI_API_KEY    Google GenAI API key (required)

Output:
  JSON object with operation information printed to stdout:
  {
    "name": "operations/abc123",
    "done": false,
    "metadata": {
      "createTime": "2024-01-01T00:00:00Z"
    }
  }

Next Steps:
  1. Poll operation status:
     tsx poll-veo3.ts operations/abc123

  2. Download completed video:
     tsx download-veo3.ts operations/abc123
`);
}

/**
 * Validate arguments
 */
function validateArguments(args: ReturnType<typeof parseArguments>) {
  const errors: string[] = [];

  // Check for required prompt
  if (!args.prompt) {
    errors.push('--prompt is required');
  }

  // Check for conflicting options
  if (args.image && args['generate-image']) {
    errors.push('Cannot use both --image and --generate-image');
  }

  // Check API key
  if (!process.env.GOOGLE_GENAI_API_KEY) {
    errors.push('GOOGLE_GENAI_API_KEY environment variable is required');
  }

  return errors;
}

/**
 * Generate image with Nano Banana (Gemini)
 */
async function generateImage(ai: GoogleGenAI, prompt: string): Promise<{ imageBytes: Buffer; mimeType: string }> {
  console.error('[VEO3] Generating first frame with Nano Banana (Gemini)...');

  const imageResponse = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    prompt: prompt,
  });

  if (!imageResponse.generatedImages || imageResponse.generatedImages.length === 0) {
    throw new Error('No image generated by Nano Banana');
  }

  console.error('[VEO3] First frame generated successfully');

  return {
    imageBytes: Buffer.from(imageResponse.generatedImages[0].image.imageBytes),
    mimeType: 'image/png',
  };
}

/**
 * Load image from file
 */
function loadImage(imagePath: string): { imageBytes: string; mimeType: string } {
  console.error(`[VEO3] Loading image from ${imagePath}...`);

  const imageBuffer = readFileSync(imagePath);
  // Convert Buffer to base64 string (required by SDK)
  const imageBytes = imageBuffer.toString('base64');

  // Determine mime type from extension
  let mimeType = 'image/png';
  if (imagePath.endsWith('.jpg') || imagePath.endsWith('.jpeg')) {
    mimeType = 'image/jpeg';
  } else if (imagePath.endsWith('.webp')) {
    mimeType = 'image/webp';
  }

  console.error('[VEO3] Image loaded successfully');

  return { imageBytes, mimeType };
}

/**
 * Main execution
 */
async function main() {
  const args = parseArguments();

  // Show help if requested
  if (args.help) {
    showHelp();
    process.exit(0);
  }

  // Validate arguments
  const errors = validateArguments(args);
  if (errors.length > 0) {
    console.error('Error: Invalid arguments\n');
    errors.forEach((error) => console.error(`  - ${error}`));
    console.error('\nUse --help for usage information');
    process.exit(1);
  }

  try {
    const ai = new GoogleGenAI({
      apiKey: process.env.GOOGLE_GENAI_API_KEY,
    });

    console.error('[VEO3] Creating video generation job...');
    console.error(`[VEO3] Model: ${args.model}`);
    console.error(`[VEO3] Prompt: ${args.prompt}`);
    console.error(`[VEO3] Aspect Ratio: ${args['aspect-ratio']}`);
    console.error(`[VEO3] Resolution: ${args.resolution}`);
    console.error(`[VEO3] Duration: ${args.duration}s`);

    // Prepare request parameters
    const requestParams: any = {
      model: args.model,
      prompt: args.prompt,
      config: {
        aspectRatio: args['aspect-ratio'],
        resolution: args.resolution,
        durationSeconds: parseInt(args.duration || '8'),
      },
    };

    // Handle image input if specified
    if (args['generate-image']) {
      // Step 1: Generate image with Nano Banana
      const image = await generateImage(ai, args.prompt!);
      requestParams.image = image;
      console.error('[VEO3] Using generated image as first frame');
    } else if (args.image) {
      // Step 1: Load existing image
      const image = loadImage(args.image);
      requestParams.image = image;
      console.error('[VEO3] Using provided image as first frame');
    } else {
      console.error('[VEO3] Generating video from text prompt only');
    }

    // Step 2: Generate video with VEO3
    console.error('[VEO3] Starting video generation...');
    const operation = await ai.models.generateVideos(requestParams);

    console.error(`[VEO3] Operation created: ${operation.name}`);
    console.error(`[VEO3] Status: ${operation.done ? 'completed' : 'in progress'}`);

    // Output operation info as JSON to stdout
    console.log(JSON.stringify({
      name: operation.name,
      done: operation.done,
      metadata: operation.metadata,
      prompt: args.prompt,
      hasImage: !!(args.image || args['generate-image']),
      config: {
        aspectRatio: args['aspect-ratio'],
        resolution: args.resolution,
        durationSeconds: parseInt(args.duration || '8'),
      },
    }, null, 2));
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    console.error('[VEO3] Error creating video:', err.message);
    console.error('[VEO3] Stack:', err.stack);

    // Output error as JSON for machine consumption
    console.log(
      JSON.stringify(
        {
          error: {
            message: err.message,
            stack: err.stack,
          },
        },
        null,
        2
      )
    );

    process.exit(1);
  }
}

main();
